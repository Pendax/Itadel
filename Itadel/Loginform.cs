using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;


namespace Itadel
{
    public partial class Login : Form
    {
        [StructLayout(LayoutKind.Sequential)]
        private struct KBDLLHOOKSTRUCT // Contains information about a low-level keyboard input event.
        {
            public Keys key;
            public int scanCode;
            public int flags;
            public int time;
            public IntPtr extra;
        }
        
        internal static class NativeMethods // API's and their corresponding Dllimports
        {
            /* API that attempts to log a user on to the local computer.
             * Does only validate the account by using the local account database when the domainName parameter is "."
             * Does not cache credentials for the logon type used (2 / LOGON32_LOGON_NETWORK) */
            [DllImport("advapi32.dll", CharSet = CharSet.Unicode)]
            internal static extern bool LogonUser(string userName, string domainName, string password, int LogonType, int LogonProvider, ref IntPtr phToken);

            /* API that Locks the workstation's display
             * Effectively protects from unauthorized use in case of program failure */
            [DllImport("user32.dll")]
            internal static extern void LockWorkStation();

            /* API that monitor the system for certain types of events 
             * Installs a hook procedure that monitors low-level keyboard input events with LowLevelKeyboardProc callback */
            [DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
            internal static extern IntPtr SetWindowsHookEx(int id, LowLevelKeyboardProc callback, IntPtr hMod, uint dwThreadId);

            // API that removes the hook procedure installed in a hook chain by the SetWindowsHookEx function
            [DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
            internal static extern bool UnhookWindowsHookEx(IntPtr hook);

            // API that passes the hook information to the next hook procedure in the current hook chain
            [DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
            internal static extern IntPtr CallNextHookEx(IntPtr hook, int nCode, IntPtr wp, IntPtr lp);

            // API that retrieves a module handle for the this process.
            [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
            internal static extern IntPtr GetModuleHandle(string name);

            // API determines whether a key is up or down at the time the function is called
            [DllImport("user32.dll", CharSet = CharSet.Unicode)]
            internal static extern short GetAsyncKeyState(Keys key);
        }

        // Used in the functions handling focusloss and closure of Loginform
        public bool PreventClose = Properties.Settings.Default.PreventClose;

        // Used in the functions handling keypresses
        private bool IsPressed = false;

        // Used in the functions handling login and authentications
        public string UserAccess; // Users allowed to unlock
        public bool DefineDomain = Properties.Settings.Default.DomainAccess; // How domain should be defined

        // Used in the functions handling hooks
        private IntPtr ptrHook; // Pointer to hook
        internal delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam); // Pointer to the Callback
        internal LowLevelKeyboardProc objKeyboardProcess; // Callback used in the SetWindowsHookEx API 
        private bool HasAltModifier(int flags)
        {
            return (flags & 0x20) == 0x20; // Detect if the Alt key is pressed
        }

        public Login()
        {
            // Activating hooks
            ProcessModule objCurrentModule = Process.GetCurrentProcess().MainModule;
            objKeyboardProcess = new LowLevelKeyboardProc(CaptureKey);
            ptrHook = NativeMethods.SetWindowsHookEx(13, objKeyboardProcess, NativeMethods.GetModuleHandle(objCurrentModule.ModuleName), 0);
            
            // Initializing the form (this is autogenerated and required)
            InitializeComponent();
        }

        /* Function to create hooks to block Windowskeys and keyboard shortcuts 
         * Except Alt + Ctrl + Del and Alt + F4 is handled in Lock_Focusloss */
        private IntPtr CaptureKey(int nCode, IntPtr wp, IntPtr lp)
        {
            if (nCode >= 0)
            {
                KBDLLHOOKSTRUCT objKeyInfo = (KBDLLHOOKSTRUCT)Marshal.PtrToStructure(lp, typeof(KBDLLHOOKSTRUCT));

                // Blocked combinations
                if    (objKeyInfo.key == Keys.RWin 
                    || objKeyInfo.key == Keys.LWin 
                    || objKeyInfo.key == Keys.Tab && HasAltModifier(objKeyInfo.flags) 
                    || objKeyInfo.key == Keys.Escape && HasAltModifier(objKeyInfo.flags) 
                    || objKeyInfo.key == Keys.Escape && (ModifierKeys & Keys.Control) == Keys.Control)
                {
                    return (IntPtr)1; // 1 means blocked, 0 means allowed
                }
            }
            return NativeMethods.CallNextHookEx(ptrHook, nCode, wp, lp);
        }

        // Function to define Loginform Opacity, Loginform, Lockscreen and mouse visibility
        private void Showing(double Opac, bool Form, bool Locked, bool Mouse)
        {
            Opacity = Opac;
            Menu.Visible = Form;
            Lock.Visible = Locked;
            if (Mouse)
            {
                Cursor.Show();
            }
            else
            {
                Cursor.Hide();
            }

        }

        /* Function to control events on login attempt
         * Opens the settings or closes the application depending on settings selection and releases the mouse in case of successful login
         * Shows Accessdenied and Restrains the mouse to the new size of Loginform in case of unsuccessful login */
        private void LogonSuccess(bool issuccess)
        {
            if (issuccess) // Successful login
            {
                PreventClose = false;
                if (Settings.Checked) // Show settings
                {
                    UserSettings Startup = new UserSettings();
                    Startup.Show();
                    Hide();
                }
                else
                {
                    Application.Exit(); // Close application
                }
                Cursor.Clip = Screen.PrimaryScreen.Bounds;
            }
            else // Unsuccessful login
            {
                PAccess.Visible = true;
                Cursor.Clip = Menu.Bounds;
            }
        }

        // Function to Fade the Lockscreen
        private async void Fade(Form e, int interval = 20)
        {
            // Fadein
            while (Opacity < 1.0 && Menu.Visible == false)
            {
                await Task.Delay(interval);
                Opacity += 0.05;
            }
            Opacity = 1.0;

            // Milliseconds the Lockscreen is shown
            await Task.Delay(125); 

            // Fadeout
            while (Opacity > 0.01 && Menu.Visible == false)
            {
                await Task.Delay(interval);
                Opacity -= 0.05;
            }
            // Ensure that Loginform doesn't fade 
            if (Menu.Visible)
            {
                Opacity = 1;
            }
            else
            {
                Opacity = 0.01;
            }
        }

        /* Function that retrives the current user 
         * Used when only active user is allowed to unlock the application */
        private string GetloggedinUserName()
        {
            System.Security.Principal.WindowsIdentity currentUser = System.Security.Principal.WindowsIdentity.GetCurrent();
            return currentUser.Name;
        }

        // Function that uses the Logon API to authenticate the provided logon information
        private bool IsValidateCredentials(string userName, string password, string domain)
        {
            IntPtr tokenHandler = IntPtr.Zero;
            bool isValid = NativeMethods.LogonUser(userName, domain, password, 2, 0, ref tokenHandler);
            return isValid;
        }

        // Function that defines the domain provided based on user selection from UserSettings
        private string GetDomain()
        {
            string domain;
            if (DefineDomain) // If user is required provide domain
            {
                domain = txtDomain.Text.Trim(); 
            }
            else
            {
                if (UserAccess == "Local") // If exclusive access to local user is selected
                {
                    domain = ".";
                }
                else // Retrives domain in case user isnt required to provide it
                {
                    domain = Environment.UserDomainName;
                }
            }
            return domain;
        }

        /* Event triggered in case of Lockscreen losing focus
         * Used as a failsafe if user manages to click on object while Lockscreen active or bootable device being inserted 
         * Uses the LockWorkStation API to lock of the machine and close the application 
         * Also triggers when Alt + Ctrl + Del or Alt + F4 is pressed */
        private void Lock_Focusloss(object sender, EventArgs e)
        {
            if (PreventClose)
            {
                PreventClose = false;
                Application.Exit();
                NativeMethods.LockWorkStation();
            }
        }

        /* Event triggered when the Login button is clicked or enter is pressed
         * Uses GetloggedinUsername, IsValidateCredentials, GetDomain and the user-provided information to unlock */
        private void Send_Click(object sender, EventArgs e)
        {
            bool issuccess = false;
            string username = GetloggedinUserName();

            switch (UserAccess)
            {
                default:
                    break;
                case ("Local"): // Local user
                    issuccess = IsValidateCredentials(txtUser.Text.Trim(), txtPwd.Text.Trim(), GetDomain());
                    break;
                case ("DomainSingle"): // Active user
                        if (username.ToLowerInvariant().Contains(txtUser.Text.Trim().ToLowerInvariant()))
                            issuccess = IsValidateCredentials(txtUser.Text.Trim(), txtPwd.Text.Trim(), GetDomain());
                    break;
                case ("Domain"): // All domain registered users
                    issuccess = IsValidateCredentials(txtUser.Text.Trim(), txtPwd.Text.Trim(), GetDomain());
                    break;
            }
            LogonSuccess(issuccess);
        }

        /* Event triggered when the Close button is pressed or escape is pressed 
         * Uses Showing to define opacity 1%, Lockscreen showing and mouse hidden */
        private void Close_Click(object sender, EventArgs e)
        {
            Showing(0.01, false, true, false);
            ActiveControl = null;
        }

        // Event triggered when user presses a key 
        private void Login_KeyDown(object sender, KeyEventArgs e)
        {
            // shows Loginform in case of enter or space
            if (e.KeyCode == Keys.Enter || e.KeyCode == Keys.Space && !IsPressed) 
            {
                IsPressed = true;
                Showing(1, true, false, true);
            }
            // Fades the Lockscreen when key pressed isn't enter or space
            else 
            {
                if (Opacity == 0.01 && !IsPressed)
                {
                    IsPressed = true;
                    e.SuppressKeyPress = true;
                    Fade(this, 4);
                }
            }
        }

        /* Event triggered when key is released
         * Used to stop Lockscreen from repeatedly showing on single key being hold */
        private void Login_KeyUp(object sender, KeyEventArgs e)
        {
            if (IsPressed)
            {
                IsPressed = false;
            }
        }

        /* Event triggered when the mouse is clicked
         * Uses Showing to define opacity 100%, Loginform and mouse showing */
        private void Login_Click(object sender, EventArgs e)
        {
            Showing(1, true, false, true);
        }

        /* Event triggered when mouse is moved on form 
         * Binds the mouse to the borders of the Loginform
         * Used to block ability to click other windows defined as being topmost such as windows applications */
        private void Login_MouseMove(object sender, MouseEventArgs e)
        {
            if (Opacity == 0.01)
            {
                Cursor.Clip = Menu.Bounds;
            }
        }

        /* Event triggered when the Loginform is loaded
         * Used to hide and bound the mouse and define the text of the Accessdenied */
        private void Login_Load(object sender, EventArgs e)
        {
            // Users allowed to unlock
            if (Properties.Settings.Default.LocalAccess)
            {
                UserAccess = "Local";
            }
            else
            {
                UserAccess = "Domain";
                if (Properties.Settings.Default.UserAccess)
                {
                    UserAccess = "DomainSingle";
                }
            }

            // Mouse restrictions
            Cursor.Clip = Menu.Bounds;
            Cursor.Hide();

            // Accessdenied appearance and text
            string Comb = "";
            string Invalid = "";

            if (DefineDomain) // User required to provide domain
            {
                Comb = "The username, password and domain";
                PDomain.Visible = true;
            }
            else // User not required to provide domain
            {
                Comb = "The username and password";
                PDomain.Visible = false;
            }

            switch (UserAccess)
            {
                default:
                    break;
                case "Local": // Local User
                    Invalid = " combination entered is either invalid or not the local user";
                    break;
                case "DomainSingle": // Active User
                    Invalid = " combination entered is either invalid or not the active user";
                    break;
                case "Domain": // All domain registered users
                    Invalid = " combination entered is invalid";
                    break;
            }

            // Combines domain text and user text
            string v = Comb + Invalid;
            Accessdenied.Text = v;

            Settings.Visible = Properties.Settings.Default.AllowSettings;
        }

        /* Event triggered when the Loginform is closing
         * Used cancel closing of the application except in case of Windows Shutdown */
        private void Login_FormClosing(object sender, FormClosingEventArgs e)
        {
            switch (e.CloseReason)
            {
                case CloseReason.WindowsShutDown:
                    PreventClose = false;
                    break;
                default:
                    if (PreventClose)
                        e.Cancel = true;
                    break;
            }

            if(Settings.Checked)
                Properties.Settings.Default.AllowSettings = true;
            else
                Properties.Settings.Default.AllowSettings = false;
            Properties.Settings.Default.Save(); 
        }
    }
}
